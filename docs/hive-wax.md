## Ultimate Guide to the Hive WAX Library

### Introduction to Hive WAX and Hive Basics

WAX Library Overview: The Hive WAX library is a next-generation, multi-language toolkit for interacting with the Hive blockchain. WAX (short for Web API eXtension for Hive, not to be confused with the unrelated [WAX blockchain) provides a unified interface to build transactions, call APIs, and manage keys across](https://developers.hive.io/quickstart/#:~:text=Wax%20is%20a%20multi,with%20the%20core%20blockchain%20protocol) different programming languages (currently JavaScript/TypeScript, C++, and Python) [1](https://developers.hive.io/quickstart/#:~:text=Wax%20is%20a%20multi,with%20the%20core%20blockchain%20protocol) . All WAX [implementations share the same core Hive protocol code, ensuring they stay up-to-date with the latest](https://developers.hive.io/quickstart/#:~:text=Wax%20is%20a%20multi,with%20the%20core%20blockchain%20protocol) blockchain operations and hardfork changes without manual updates [1](https://developers.hive.io/quickstart/#:~:text=Wax%20is%20a%20multi,with%20the%20core%20blockchain%20protocol) . In other words, WAX uses Hive’s own protocol definitions (via Protocol Buffers) to represent transactions and operations, which guarantees compatibility with the blockchain’s rules at all times.

Hive Blockchain Recap: For developers new to Hive, here are key points to understand its environment (in brief):

- Fee-less Transactions: Hive is a Delegated Proof-of-Stake blockchain that does not charge gas fees. Instead, it uses a Resource Credit (RC) system and stake-based bandwidth. Every account has Resource Credits (based on staked Hive Power) that recharge over time, allowing “free” transactions up to certain limits.

- Account and Key Model: Hive accounts are human-readable usernames (e.g. alice , gtg ). Each account has multiple cryptographic key pairs for different roles: Owner, Active, Posting, and Memo. The Owner key controls the account (used for recovery), the Active key authorizes financial and governance actions, the Posting key is for social actions (posting, voting) without risking funds, and the Memo key is for encrypting memos. This means developers must manage multiple keys per user account depending on the operation. WAX’s key tools accommodate generating or using keys for these roles.

- Operations vs. Smart Contracts: Hive does not have user-defined smart contracts. Instead, it has a rich set of built-in operations (like transfers, posts, votes, custom JSONs, etc.) that cover social media, token transfers, governance, and more. Hive apps often leverage custom JSON operations as a way to implement second-layer logic (for example, communities, follows, games). WAX is designed to help construct and broadcast these operations easily.

- Consensus and Finality: Hive produces blocks every 3 seconds via witnesses (delegated consensus). Transactions are typically confirmed within 1 block. A concept called TaPoS (Transaction as Proof of [Stake) requires including a recent block reference in every transaction to prevent replay attacks on](https://hive.pages.syncad.com/wax-doc/default/interfaces/transaction-and-operation/#:~:text=The%20hive%20software%20requires%20every,This%20hash%20serves%20two%20purposes) forked chains [2](https://hive.pages.syncad.com/wax-doc/default/interfaces/transaction-and-operation/#:~:text=The%20hive%20software%20requires%20every,This%20hash%20serves%20two%20purposes) . WAX handles this automatically when building transactions.

In summary, WAX acts as a bridge between your application and the Hive blockchain. It simplifies reading data from Hive nodes and writing new data (transactions) to Hive, all while abstracting the complexity of the protocol. In the next sections, we’ll dive into how to set up WAX in a JavaScript project, use its core interfaces, manage keys securely, build and broadcast transactions, and even leverage advanced features like custom JSON operations for social features. We’ll also compare WAX to older Hive libraries to highlight where it shines and what trade-offs it has.

### Installation and Setup (JavaScript)

WAX is available via npm as @hiveio/wax . You can install it using your preferred package manager. For example, using pnpm (or npm/yarn): pnpm add @hiveio/wax This will install the WAX library into your project. Since we’ll focus on JavaScript/TypeScript usage (Node.js or browser), ensure you have a modern environment that supports ES2017+ syntax (for async/await). If using in a browser, you will need to bundle the library (with webpack, etc.) or use a CDN build if provided.

Note: WAX is often used alongside BeeKeeper ( @hiveio/beekeeper ) – a companion library for secure key storage and transaction signing – and possibly Workerbee (an automation toolkit built on WAX).

However, for core blockchain interactions, @hiveio/wax is the main dependency.

### WAX Library Architecture: Base vs. Chain Interface

The WAX library provides two primary ways to interact with it: the Base interface and the Chain interface.

These correspond to two levels of functionality:

- Base Interface (Offline) – a low-level interface that does not require an API node endpoint. It contains fundamental operations that can be done offline or without network communication. This includes constructing transactions from given data, formatting and parsing assets, and cryptographic utilities. You might use the Base interface for tasks like offline transaction signing or working with data you already have. However, since Hive transactions usually need current blockchain data (like ref blocks), completely offline use is limited to specific scenarios.

- Chain Interface (Online) – a higher-level interface that connects to a Hive API node (RPC endpoint) and provides full network functionality. This interface extends the Base interface with network calls. Using the Chain interface, you can easily fetch required blockchain data on the fly and broadcast transactions. It comes pre-configured with all standard Hive APIs (such as database_api , network_broadcast_api , account_by_key_api , rc_api , etc.), and even allows custom remote procedure calls via an extendable mechanism. In practice, most WAX usage will involve the Chain interface, since it automates many steps (like TaPoS data fetching) needed to craft valid transactions.

Design Philosophy: WAX’s interface is object-oriented and unified. Instead of having many disparate functions for each operation, it provides a consistent way to build any operation and transaction. Under the hood, WAX uses the official Hive Protocol definitions (Protobuf) for all operations and types. This means whether you’re using WAX in JavaScript, C++, or Python, the data structures and behaviors are the same. It also means when Hive introduces a new operation or changes the protocol in a hardfork, WAX will support [it by virtue of using the updated protocol definitions (often with minimal changes required in your code)](https://developers.hive.io/quickstart/#:~:text=Wax%20is%20a%20multi,with%20the%20core%20blockchain%20protocol) [1](https://developers.hive.io/quickstart/#:~:text=Wax%20is%20a%20multi,with%20the%20core%20blockchain%20protocol) . This is a significant improvement over older libraries that required manual updates for new operations.

When to use Base vs. Chain: In almost all cases, you will create a Chain instance (which internally includes Base features) when working with Hive, because you’ll need to query the blockchain (for example, to get

ref_block data or current pricing for conversions) or broadcast transactions. The Base interface (accessible via createWaxFoundation() in code) is mainly useful for pure utility usage, such as converting assets or generating keys without connecting to a node. It can also be used to craft a transaction structure offline, but you would then need to bring in things like block IDs from elsewhere. One use-case for Base might be an offline signer application: you could build a transaction JSON on an online machine, transfer it to an offline machine running WAX Base to sign it, then bring the signature back online to broadcast. WAX’s separation of concerns allows for such patterns.

### Initializing the WAX Chain Interface

To start using WAX in code, you need to create an instance of the WAX interface (either Chain or Base). The library provides convenient factory functions for this. In JavaScript, you typically use the asynchronous function createHiveChain() to get a Chain interface connected to the Hive network.

Default Initialization: If you call createHiveChain() with no arguments, it will initialize with default options, connecting to the main Hive network via a default API node (e.g. https://api.hive.blog ) and using default chain parameters.

import { createHiveChain } from '@hiveio/wax'; // Initialize Hive Chain using default options (mainnet, default endpoints) const chain = await createHiveChain(); The above will yield a chain object that you can use to read from the blockchain and construct transactions. Under the hood, it knows the Hive chain ID and has a list of known public API endpoints to use.

Custom Configuration: You can also provide custom options to specify a particular endpoint, chain ID, timeout settings, or even use alternate networks like Hive’s testnet. This is done by passing an IWaxOptionsChain object to createHiveChain . For example: import { createHiveChain } from '@hiveio/wax'; const options = { chainId: 'f875a0b000000000000000000000000000000000000000000000000000000000', // custom chain ID (32-byte hex string) apiEndpoint: 'https://api.hive.blog', // specify a particular API node // You can also specify specialized endpoints per API, e.g.: // apiEndpoints: { database_api: "https://api.hive.blog", network_broadcast_api: "https://api.openhive.network", ... } // restApiEndpoint: 'https://some-rest-proxy/', // if using a REST proxy instead of direct RPC apiTimeout: 0 // timeout in milliseconds for API calls (0 to disable timeouts)

}; const chain = await createHiveChain(options); In most cases, you won’t need to set a custom chainId (the default is mainnet’s ID). But specifying custom API endpoints is useful for reliability (you might list several, or use your own node). WAX allows very granular endpoint control: you can set a global endpoint for all calls, or different endpoints for different API namespaces, or even override per individual call if needed. This can help with load balancing or using app- specific backends.

Once initialized, the chain object is your main entry point. It includes: - Methods to call blockchain APIs (e.g. chain.database.getDynamicGlobalProperties() , chain.block.getBlock(header) , etc. – these follow the structure of Hive’s remote procedure calls). - Methods to construct transactions (e.g.

chain.createTransaction() ). - Utility methods for assets and other calculations (inherited from the Base interface). - Configuration controls (like switching endpoints if one fails, etc.).

Example – Fetching Data: To illustrate, if you wanted to fetch an account’s info and print their Hive Power using chain : const account = await chain.database.getAccounts([ "someusername" ]); console.log(account[0].vesting_shares); // prints VESTS (staked hive) amount as a string, e.g. "12345.678900 VESTS" The chain interface is fully aware of available API calls and provides proper typing (if using TypeScript). You can also extend it with custom API calls (using chain.extend(...) ) for non-standard API methods; WAX will then handle calling those and even support a REST mode if desired.

We will focus primarily on transaction creation and broadcasting in this guide, but keep in mind WAX can perform read operations as well: anything a normal Hive API node can provide (account info, blocks, market feed, social data, etc.), you can retrieve through the chain object’s sub-APIs.

### Key Management and Security in WAX

Interacting with Hive inevitably involves managing private keys for accounts (to sign transactions). WAX provides tools to help generate and handle keys securely, though it deliberately does not embed any full wallet (to avoid keeping secrets directly in the library). Instead, WAX can integrate with wallet solutions like BeeKeeper or let you supply keys for signing. Here are some key-related capabilities:

- Key Generation: WAX can generate new key pairs in two ways:

- Derive keys from a master password: This mimics how Hive account creation works. Given an account name and a plaintext master password, WAX can derive the deterministic owner, active, posting, and memo private keys that would result. This is useful for account creation flows or recovering keys from a known password (similar to how HiveSigner or other tools derive keys).

- Generate a random private key: For one-off use, WAX can create a new random private key (generally for cases like creating a new account or key change).

- Brainkey (Mnemonic) Suggestion: WAX can provide a suggested brain key – essentially a long random passphrase – and derive a key pair from it. A brain key is a human-readable seed that can regenerate the same keys if you remember or store the phrase. This is helpful for backups.

- Encryption/Decryption: WAX’s Base interface includes methods to encrypt or decrypt data using keys (for example, to handle encrypted memos with memo keys). This can be used to decode memo fields or securely encrypt data to a public key.

Let’s look at a couple of examples.

Generating Private Keys from a Password If you have a username and want to derive a specific role’s key from a master password (the method Hive often uses to produce initial keys): import { createWaxFoundation } from '@hiveio/wax'; const waxBase = await createWaxFoundation(); // Base interface (no endpoint needed for keygen) const accountName = "your-account"; const role = "active"; // which key to derive: 'owner' | 'active' | 'posting' | 'memo' // WARNING: Always use a truly random, high-entropy master password for real accounts const masterPassword = "correct horse battery staple"; // example (do NOT use simple passwords) // Get the private key data const keyData = waxBase.getPrivateKeyFromPassword(accountName, role, masterPassword); console.log("Derived Public Key:", keyData.associatedPublicKey); console.log("Derived Private WIF:", keyData.wifPrivateKey); In the above, associatedPublicKey will be the public key corresponding to the derived private key (which is given in Wallet Import Format in wifPrivateKey ). You would use that WIF string as the actual private key for signing (or import it into a wallet). Hive accounts typically use this scheme when created: a random master password is generated, and from it the 4 keys are derived.

Suggesting a Brain Key (Mnemonic) If you want a deterministic key that can be backed up easily (with a phrase), WAX can generate a brain key: const brainKeyData = waxBase.suggestBrainKey(); console.log("Brain Key (mnemonic):", brainKeyData.brainKey);

console.log("Private WIF from brain key:", brainKeyData.wifPrivateKey); console.log("Public Key from brain key:", brainKeyData.associatedPublicKey); The brainKey is a long passphrase (often 16+ random words). Using the same brain key with WAX’s algorithm will always yield the same key pair. This is useful for backup/recovery: you only store the phrase, and you can re-derive the private key when needed.

Security Reminder: Always handle private keys with extreme care. Never hardcode real private keys in your source code or expose them client-side in a production app. When generating keys, save them in a secure vault or keystore. WAX itself will not send your keys anywhere – but if your app is running in a browser, you must assume anything in memory could be compromised by malicious scripts. In practice, consider using external signing solutions: - BeeKeeper: A secure wallet library (and background service) that can hold keys and sign transactions for you, without you manually handling WIF strings after import. - Hive Keychain: A browser extension that manages keys and can be invoked to sign transactions (your web app can communicate with it, leaving keys in the extension). - Hivesigner: An OAuth-like web service where users approve transactions and the service signs on their behalf (keys never touch your app).

For development and testing, you might use WIF private keys directly. But for production, plan a secure key management strategy. The examples in this guide use BeeKeeper for signing to demonstrate best practices.

### Hive Transactions and Operations: Fundamentals

Before building transactions with WAX, it’s important to understand what a Hive transaction looks like and what operations are. WAX mirrors these concepts closely with its data structures.

Transactions and TaPoS A transaction in Hive is a container for one or more operations that should be executed together. Even a single operation (like a token transfer) must be wrapped in a transaction for signing. Transactions include metadata in addition to the list of operations. The general structure of a Hive transaction is: - ref_block_num: A short reference to a recent block number. - ref_block_prefix: A derived value (32-bit) from that block’s ID. - expiration: A timestamp after which the transaction is no longer valid. - operations: An array of one or more operations (each operation is a structured command). - extensions: An array for future or special extensions (usually empty). - signatures: An array of cryptographic signatures (empty until signed).

The ref_block_num , ref_block_prefix , and expiration are part of Hive’s Transaction as Proof- of-Stake (TaPoS) mechanism. Including a piece of a recent block’s hash serves two purposes: (1) it prevents replay of this transaction on any fork of the chain that doesn’t include that block (so an attacker can’t take [your old transaction and force it into a fork you didn’t intend), and](https://hive.pages.syncad.com/wax-doc/default/interfaces/transaction-and-operation/#:~:text=The%20hive%20software%20requires%20every,This%20hash%20serves%20two%20purposes) (2) it implicitly ties your account’s stake to that fork (signaling the network which chain you support) [2](https://hive.pages.syncad.com/wax-doc/default/interfaces/transaction-and-operation/#:~:text=The%20hive%20software%20requires%20every,This%20hash%20serves%20two%20purposes) . Practically, this means whenever you create a transaction, you need to pick a recent block (within the last 1-2 minutes typically) and include its reference. WAX automates this: when using the Chain interface, calling createTransaction() will fetch the latest block info and fill these fields for you. By default, WAX sets expiration to a sensible default (often 1 minute in the future) if you don’t specify otherwise.

Operations in Hive An operation is a single action or command that the blockchain can execute. Hive defines many operations – examples include: - Transfer ( transfer_operation ): Move liquid HIVE or HBD from one account to another. - Vote ( vote_operation ): Cast a vote on a post or comment. - Comment ( comment_operation ): Create or edit a post/comment (content publishing). - Custom JSON ( custom_json_operation ): Carry arbitrary JSON data for social actions or layer-2 protocols (communities, follows, game moves, etc.). - Account Update ( account_update_operation ): Change account keys or profile metadata. - Witness Update ( witness_update_operation / witness_set_properties_operation ): Manage witness node properties. - ...and many more (there are operations for power up/down, conversions, proposals, etc).

Each operation has a defined set of fields. For example, a transfer_operation contains: - from (account sending), - to (account receiving), - amount (the asset and amount to transfer), - memo (optional string memo).

A vote_operation contains: - voter (account casting vote), - author (post author being voted on), - permlink (permlink of the post/comment), - weight (vote weight, e.g. 10000 for 100% upvote).

A comment_operation contains fields like author, permlink, title, body, json_metadata, parent_author, parent_permlink (for a top-level post, parent fields are empty; for a reply, they indicate the parent post).

Think of operations as structured data objects. In WAX (thanks to the Protobuf definitions), operations are strongly-typed objects, not just loose JSON. This means WAX knows exactly what fields each operation expects and will ensure you provide them when constructing an operation.

Protocol Buffers and Generated Classes: Hive’s use of Protocol Buffers for defining operations is a big advantage. For instance, the protocol definition for a vote operation looks like: message vote { required string voter = 10; required string author = 11; required string permlink = 12; required uint32 weight = 13; } WAX uses these definitions to generate the corresponding classes/structures in each language. This ensures that if Hive adds a new operation or a new field in a hardfork, the WAX library (once updated with the latest protocol buffer) will automatically support it. There’s no need to manually write the JSON structure – you use the properties of the operation object. This reduces errors from typos and mismatched field types. It also means that WAX can seamlessly convert between different representations (binary, JSON, etc.) of the operation.

To summarize: - A transaction groups operations and includes necessary metadata (ref block, expiration). - An operation is a discrete action with specific fields. - WAX provides classes/objects to represent operations exactly as the blockchain expects them.

Next, we’ll see how WAX helps create these objects and manage assets.

### Working with Hive Assets (HIVE, HBD, HP) in WAX

Financial values on Hive are represented by asset structures. There are three native asset types on Hive’s base layer: - HIVE: the native coin (liquid form). - HBD: Hive-Backed Dollars, a stablecoin intended to be roughly $1 (also liquid). - VESTS: the representation of staked Hive (also called Hive Power when viewed in human-readable form). VESTS are non-transferable but can be converted to and from Hive Power through staking operations.

Each asset amount in Hive is stored as an integer with a fixed precision: - HIVE and HBD have 3 decimal places (e.g., 1.234 HIVE is stored as 1234 with precision=3). - VESTS have 6 decimal places (they are very large numbers, e.g., 123456.789012 VESTS has precision=6).

Historically, Hive (and Steem before it) represented assets as a string like "100.000 HIVE" . This is now deprecated in favor of the NAI (Numeric Asset Identifier) format. NAI format uses a structured object with amount , precision , and nai fields. For example, 1.000 HIVE in NAI is: { "amount": "1000", "precision": 3, "nai": "@@000000021" } Here nai:"@@000000021" is the code for HIVE. HBD is "@@000000013" [and VESTS is](https://hive.pages.syncad.com/wax-doc/default/interfaces/asset-manipulations/construct-nai-asset/#:~:text=,and%20type%20must%20be%20specified) "@@000000037" . The numbers 21, 13, 37 are the type identifiers for those assets [3](https://hive.pages.syncad.com/wax-doc/default/interfaces/asset-manipulations/construct-nai-asset/#:~:text=,and%20type%20must%20be%20specified) . You’ll see these codes whenever assets are represented in API calls or in WAX outputs.

WAX handles assets using a class often referred to as NaiAsset. As a developer, you rarely need to construct the raw object manually – WAX provides helper methods to create assets in the correct format.

Creating Asset Objects in WAX WAX’s Chain/Base interface has convenience methods to create asset representations: - hiveCoins(value) - hbdCoins(value) - vestsCoins(value) - hiveSatoshis(value) - hbdSatoshis(value) - vestsSatoshis(value) These come in pairs: - The \*Coins() methods accept a floating-point number (or number string) in human-readable units (like 1.5 means 1.500 HIVE) and produce a NaiAsset object. - The \*Satoshis() methods accept an integer amount in the smallest unit (like satoshis, where 1 HIVE = 1000 “Hive satoshis”) and produce the NaiAsset.

For example:

const hiveAsset1 = chain.hiveCoins(2.5); // hiveAsset1 -> { amount: "2500", precision: 3, nai: "@@000000021" } which is 2.500 HIVE const hiveAsset2 = chain.hiveSatoshis(2500); // hiveAsset2 will represent 2.500 HIVE as well, same object as above.

const hbdAsset = chain.hbdCoins(100); // hbdAsset -> { amount: "100000", precision: 3, nai: "@@000000013" } (100.000 HBD) const vestsAsset = chain.vestsSatoshis(500000); // vestsAsset -> { amount: "500000", precision: 6, nai: "@@000000037" } (500000 satoshis = 0.500000 VESTS) Using these functions ensures you don’t have to manually format the asset strings. The Coins functions are easy for literal amounts in code, while Satoshis are safer if dealing with big integers or user input.

Here’s how to choose: - Use coins functions for fixed or floating values you know (e.g., converting a constant or calculation result). They handle decimal notation (but be mindful of JavaScript’s floating-point limits). - Use satoshis functions for exact integer values or when dealing with big numbers (they support JavaScript BigInt if needed, so they won’t lose precision even for very large VESTS counts).

Precision Handling: The coins methods will automatically pad or trim the decimal to the allowed precision: - If you give fewer decimal places than required, it will pad with zeros (e.g.

chain.hiveCoins(5.2) becomes "5.200 HIVE" [internally). - If you give more decimal places than](https://hive.pages.syncad.com/wax-doc/default/interfaces/asset-manipulations/generating-assets/#:~:text=%2F%2F%20Example%20of%20exceeding%20the,precision%20limit%20for%20fractional%20parts) allowed, it will truncate the extra digits without rounding [4](https://hive.pages.syncad.com/wax-doc/default/interfaces/asset-manipulations/generating-assets/#:~:text=%2F%2F%20Example%20of%20exceeding%20the,precision%20limit%20for%20fractional%20parts) . For instance, [chain.hiveCoins(100.123456)](https://hive.pages.syncad.com/wax-doc/default/interfaces/asset-manipulations/generating-assets/#:~:text=%2F%2F%20Example%20of%20exceeding%20the,precision%20limit%20for%20fractional%20parts) will cut off to "100.123 HIVE" (3 decimals for HIVE) with no rounding down or up [4](https://hive.pages.syncad.com/wax-doc/default/interfaces/asset-manipulations/generating-assets/#:~:text=%2F%2F%20Example%20of%20exceeding%20the,precision%20limit%20for%20fractional%20parts) . Similarly for HBD, and for VESTS it cuts to 6 decimals. - The satoshis methods expect you to already multiply out the decimals. So chain.hiveSatoshis(1000) means 1000 “satoshi” units = 1.000 HIVE. If you pass 1001, that’s 1.001 HIVE. There’s no rounding because you provide the exact integer.

In general, using coins() is more convenient for everyday values, but if you’re doing math or handling user input as strings/ints, satoshis() can avoid floating point issues.

Asset Conversion Utilities Hive has a couple unique conversions: - VESTS <-> Hive Power (HP): Hive Power is just VESTS shown in a friendlier way. The blockchain maintains global values of total VESTS vs total staked HIVE. To convert an amount of VESTS to an equivalent amount of Hive (HP), you need to use the formula: HP = (vests / total_vesting_shares) \* total_vesting_fund_hive .

WAX provides a method vestsToHp(vestsAsset, totalVestingFundHiveAsset, totalVestingSharesAsset) to do this easily. It returns an asset object for HP (which is actually a HIVE asset representation, since HP is measured in Hive units). You can also do the inverse with hpToVests() if needed. - HBD <-> HIVE Conversions (Savings conversion): On Hive, there’s a mechanism to convert

HBD to Hive over a 3.5 day period based on the median price feed. If you retrieve the current price feed (via database_api.get_current_price_feed which gives you a base and quote asset), you can calculate roughly how much Hive you’d get for a given HBD. WAX provides hbdToHive(hbdAsset, baseAsset, quoteAsset) to compute this. Essentially, given a certain base (e.g. "1.234 HBD" ) and quote ( "5.678 HIVE" ) from the feed, it will compute hbd_amount \* (quote/base) internally to output a Hive asset. The inverse hiveToHbd() is also available.

Example – Converting VESTS to Hive Power: // Suppose user_vests, totalVests, totalHiveFund are obtained from blockchain: const vests = chain.vestsSatoshis(1_000000); // e.g. user has 1.000000 VESTS const totalVests = chain.vestsSatoshis(5_000000); // total vesting shares global const totalHiveFund = chain.hiveSatoshis(20_000); // total vesting fund hive global const hpAsset = chain.vestsToHp(vests, totalHiveFund, totalVests); console.log("Converted Hive Power:", hpAsset); // Example output: { amount: "4000", precision: 3, nai: "@@000000021" } meaning 4.000 HIVE (HP) (The numbers above are arbitrary; in reality the global values are huge, and the result would depend on actual blockchain data.) Example – Converting HBD to Hive: // Assume we got price feed: const feedBase = chain.hbdSatoshis(1000); // e.g. "1.000 HBD" (base of the conversion rate) const feedQuote = chain.hiveSatoshis(2500); // e.g. "2.500 HIVE" (quote of the conversion rate) // We want to convert 10.000 HBD: const amountHbd = chain.hbdSatoshis(10000); const estHive = chain.hbdToHive(amountHbd, feedBase, feedQuote); console.log("Estimated Hive from conversion:", estHive); If the feed was 1 HBD = 2.5 HIVE, converting 10 HBD should yield \~25 HIVE (in the asset object form).

These utility functions spare you from doing the math and formatting on your own. Just be sure to pass in NaiAsset objects or values that can be converted to those (WAX will accept raw numbers or strings and internally call the appropriate conversion).

### Building and Signing Transactions with WAX

Now we get to the core of using WAX: creating transactions, adding operations, and getting them signed/ broadcast. The WAX library offers an ITransaction interface (exposed via objects you create) that provides a fluid way to construct transactions step by step.

Creating a New Transaction Using the Chain interface ( chain object), you can create a new transaction by calling: const tx = await chain.createTransaction(); This returns a transaction builder object (implementing ITransaction). Crucially, createTransaction() will automatically fetch the needed TaPoS reference block data from the network. That means tx already has ref_block_num , ref_block_prefix , and a provisional expiration set. By default, expiration is current time + 1 minute. You can override this by passing a parameter: - await chain.createTransaction('+10m') would set expiration 10 minutes from head block time. - await chain.createTransaction(new Date('2025-09-08T15:30:00Z')) would set an absolute expiration time (be careful to ensure it’s in the future and within 1 hour of ref block or it won’t be accepted).

If you needed to, you could also create a transaction using the Base interface with custom TaPoS data (e.g., base.createTransaction(refBlockId, expireSeconds) ), but again, using the Chain method is simpler and less error-prone.

At this point, the tx is empty (no operations yet) and unsigned. Think of it like a mutable transaction builder.

Adding Operations to a Transaction WAX provides two ways to add an operation: 1. Directly providing an operation object/dictionary – This is used for simple operations where you manually specify the fields. 2. Using operation builder classes – These are higher-level classes for complex or grouped operations (like custom JSON actions) that help construct the needed operation(s) correctly.

The simplest way is to push a plain operation. For example, to add a vote operation: const voteOp = { vote_operation: { // note: the key is the operation name with \`\_operation\` suffix voter: "voter_account", author: "author_account", permlink: "post-permlink", weight: 10000 // 100.00% upvote; use 0 to downvote if needed }

}; tx.pushOperation(voteOp); After this, the transaction tx contains one operation (the vote). We can inspect it: console.log(tx.transaction.operations); This might log something like: [ { vote\_operation: { voter: 'voter\_account', author: 'author\_account', permlink: 'post-permlink', weight: 10000 } } ] WAX stores operations internally in a normalized way (using the proper types/fields). Note, if we were on a pre-HF26 setup, operations would be stored as an array ["vote", {...}] for legacy format, but WAX by default works in post-HF26 format (object with type and value if converted to JSON). WAX can output either format on demand (we’ll see that in Finalizing Transactions).

Complex Operations via Classes: Some operations, especially those involving binary serialization of data or multiple steps, are easier to handle with WAX’s provided classes. For instance, witness node properties require packaging data into a specific binary format – WAX offers a WitnessSetPropertiesOperation class to do that for you by just giving it the new values. Another example is the content publishing operations ( CommentOperation , CommentOptionsOperation ) where WAX can help format the json_metadata or beneficiary fields.

For a demonstration, consider updating a witness signing key (an advanced action only witnesses do): import { WitnessSetPropertiesOperation } from '@hiveio/wax'; const propsOp = new WitnessSetPropertiesOperation({ owner: 'your-witness-account', witnessSigningKey: publicKey1, // a public key (perhaps from BeeKeeper or generated) url: 'https://example.com' // your witness URL }); tx.pushOperation(propsOp); Behind the scenes, WitnessSetPropertiesOperation takes the human-readable inputs and converts them into the props map that the blockchain expects (including hex encoding the URL and key). After pushing, tx.transaction.operations[0] would contain something like:

{ witness_set_properties_operation: { owner: 'your-witness-account', props: { key: '02ABCDEF1234...5678', // hex value of public key url: '68747470733a2f2f6578616d706c652e636f6d' // hex of the URL string }, extensions: [] } } WAX handled encoding the URL to hex and formatting the key appropriately. As a developer, using these classes saves you from manual byte conversions.

For everyday app development, you might not need witness operations, but you might use provided classes for posting content (WAX has PostOperation or ReplyOperation to help build a comment + its comment_options with beneficiaries in one go), or for custom JSON ops like follows and communities (discussed later).

Multiple Operations: You can call tx.pushOperation(...) as many times as needed to add multiple operations to one transaction. Hive will execute all operations atomically – either all succeed or all fail.

Common multi-operation transactions include posting (which requires a comment and a comment_options operation together), or power up with transfer (not common, but possible). With WAX, just keep pushing ops before signing.

Reading or Modifying Transaction Properties While building a transaction, you might need to inspect some properties: - tx.id gives the transaction ID (hash) if the transaction is filled and signed. (If not signed, Hive can’t assign an ID yet; WAX may compute a temporary digest for you but ID is typically meaningful after signing.) - tx.sigDigest gives the signature digest (the hash that needs to be signed) for the transaction in its current state. This is useful if you want to manually sign using some custom crypto. - tx.transaction.expiration etc. to read the fields.

For example: console.log("Transaction ID (currently):", tx.id); console.log("Signature digest:", tx.sigDigest); console.log("Expiration time:", tx.transaction.expiration); console.log("Ref block num:", tx.transaction.ref_block_num); Before signing, tx.id may be null or not finalized. After signing (and especially after broadcasting), tx.id would be the transaction hash.

You can also modify certain things like expiration if needed:

tx.transaction.expiration = new Date(Date.now() + 300000).toISOString().slice(0,-5); // extends expiration 5 minutes from now (must be string YYYY-MM-DDThh:mm:ss format without timezone) However, generally you set expiration via createTransaction parameter or not at all.

Online Transaction Features: Verification and Safety One powerful aspect of WAX’s Chain transactions (the Online Transaction class) is that it can verify your transaction against the blockchain state before you send it. This is an optional but highly recommended step to catch mistakes or issues early. By calling await tx.performOnChainVerification() , WAX will do a series of checks, such as: - Private Key Leak Check: It scans any text fields (like memos, post bodies, comments) for patterns that match a private key (e.g., a 51-character WIF starting with '5' or hex keys). This prevents accidentally posting your private key or including it in a transfer memo (a surprising number of users have accidentally done this!). If such a pattern is found, it throws an error like “Potential private key leak detected!” and refuses to proceed. - Account Existence Check: It verifies that any account names referenced in the ops exist on the blockchain. For example, if you try to transfer to a username that’s not registered, it will flag that. This can save you from losing funds by mistyping an account name (Hive would reject the transfer anyway, but catching it client-side is nice). - Authority and Safety Check: For operations that modify account authorities or sensitive settings, it checks that you’re not doing something obviously dangerous. For instance, if you were updating your account keys, it might ensure you’re not removing all your active keys or lowering weight thresholds incorrectly. - Proper Key for Operation: It can ensure that the transaction is signed with keys that have the required authority for the operations included (if you have already added signatures or have BeeKeeper signers attached).

When you ultimately call chain.broadcast(tx) , WAX by default will run performOnChainVerification() internally on an online transaction to protect you. You can manually call it earlier if you want to handle the errors programmatically.

Example – Using performOnChainVerification(): tx.pushOperation({ transfer_operation: { from: "alice", to: "bob", amount: chain.hiveCoins(5), memo: "Here is my private key: 5KQwrPbwdL6PhX..." // an obviously dangerous memo } }); try { await tx.performOnChainVerification(); console.log("Transaction passed on-chain verification!"); } catch (err) {

console.error("Verification failed:", err.message); // In this case, err.message might be "Potential private key leak detected!"

because of the memo.

} In this snippet, the verification would throw an error due to the memo containing something that looks like a private key. Thus, the transaction would not be broadcast unless the issue is fixed (e.g., remove that memo or secure it properly).

Another aspect of verification is authority checking. Hive transactions may sometimes require multiple signatures (for example, an account has a weighted authority, or you’re doing a multi-sig that needs two keys). WAX can simulate the authority check and even provide a trace of how the authority was satisfied by the provided signatures. This is quite advanced debugging info, but it’s available via tx.generateAuthorityVerificationTrace() .

If you call: const trace = await tx.generateAuthorityVerificationTrace(useLegacySerialization=false, someTransactionObject); console.log(trace); It would output a detailed JSON of which keys or accounts were tried for each required authority, which ones passed, and which signatures matched which keys. This is primarily useful if you have complex account authorities (like a joint account controlled by multiple people) and you want to confirm that the transaction has all necessary signatures before sending it out.

For most developers, simply knowing that performOnChainVerification() exists and is auto-invoked is enough. It provides peace of mind that obvious mistakes (wrong accounts, leaking keys, missing authority) will be caught. This kind of safety net did not exist in older libraries – it’s a major benefit of WAX.

Signing Transactions with BeeKeeper (or Other Signers) After building the transaction and verifying it, the next step is to sign it. Signing produces a cryptographic signature (or multiple signatures) proving that you own the keys required for the transaction’s operations.

In Hive, typically: - Posting operations (votes, comments, follows, etc.) require the Posting key of the account(s). - Financial operations (transfers, power up/down, conversions) require the Active key. - Some governance ops (witness actions, proposal creation) require Active, and changing Owner requires Owner.

If multiple accounts or a multi-sig authority are involved, you might need multiple signatures.

WAX itself does not automatically have your private keys to sign (which is good for security). Instead, you use a signer. A signer is any object that implements a method to take a transaction digest and return a signature. The recommended approach is to use the BeeKeeper wallet library. BeeKeeper can hold keys in- memory or in a secure enclave and expose signer objects for each key.

For example, if you have imported a private key into BeeKeeper (say BeeKeeper’s wallet now has a key for public key STM...xyz which corresponds to account Alice’s active key), you can get a signer for it: const { signer1 } = globalThis.snippetsBeekeeperData; // (In WAX’s docs environment, they prepared signer1, signer2 etc. with keys.) await signer1.signTransaction(tx); Calling signer1.signTransaction(tx) will sign the transaction and attach the signature to tx . If tx already had another signature, the new one is added (so WAX supports multi-sign easily by just calling multiple signers). After signing, you can see the signatures via tx.transaction.signatures array.

Alternate Signing: If you are not using BeeKeeper, you could manually sign by getting the tx.sigDigest and using a crypto library to produce a signature with your private key. WAX expects a DER-encoded signature or a 65-byte compact signature (which includes recovery ID) in hex form. However, using BeeKeeper or similar is far simpler. In browser environments, you might instead hand off the transaction to Hive Keychain or HiveSigner. For example, Hive Keychain allows your webpage to request a transaction signature from the extension; you would use tx.toLegacyApi() (to get the old format JSON) and pass it to Keychain’s request. The signed transaction (returned by Keychain) could then be broadcast via WAX.

For completeness, WAX does have a method tx.addSignature(signatureString) if you somehow obtained a signature out-of-band and want to attach it.

Example – Sign and broadcast: // Assume tx has been built with operations await signer1.signTransaction(tx); // sign with one key (e.g., alice’s active key) console.log("Signature 0:", tx.transaction.signatures[0]); // If needed, sign with another key for multisig: await signer2.signTransaction(tx); console.log("Signature 1:", tx.transaction.signatures[1]); // Finally, broadcast the transaction to the network: await chain.broadcast(tx); console.log("Transaction broadcast! ID:", tx.id); The chain.broadcast(tx) call will submit the transaction to the connected API node. If the node accepts it, the transaction will be processed in the blockchain (if something was wrong, an error would be thrown – perhaps if it was expired or a wrong signature, etc.). Note that tx.id (transaction ID) typically becomes available after signing, but it’s officially finalized when included in a block. You can use tx.id to look up the transaction on a block explorer or via an API call to confirm it went through.

WAX’s broadcast function ensures the transaction is in the proper format and, as mentioned, by default does the on-chain verification step beforehand for safety.

Transaction Formats (API vs Legacy): WAX can output your transaction in either of the two JSON formats: - Modern format (HF26+): operations are objects with "type": "something_operation", "value": {..} and there is no separate extensions array in operations (they appear inside value if needed). - Legacy format (pre-HF26): operations are arrays like ["vote", { ... }] and certain aspects differ.

If you call tx.toApi() , you’ll get the transaction in the modern JSON format (as used by condenser_api after HF26). If you call tx.toLegacyApi() , you get a JSON string formatted as it would have been before HF26. The legacy format might be needed if you are feeding the transaction to older systems or libraries that expect the old style. For most use cases, toApi() is fine. In fact, chain.broadcast() will handle the correct formatting for the API – you can just pass the tx object itself.

Example – Getting JSON for debugging: const unsignedTxJson = tx.toApi(); console.log("Transaction (unsigned) in API format:", unsignedTxJson); tx.addSignature('1f...ab'); // (just for example, adding a dummy signature string) const signedTxJson = tx.toApi(); console.log("Transaction (signed) in API format:", signedTxJson); // Legacy format string: const legacyJsonStr = tx.toLegacyApi(); console.log("Legacy format transaction JSON:", legacyJsonStr); The outputs will show the structure. For instance, toApi() might output: { "ref_block_num": 1960, "ref_block_prefix": 3915120327, "expiration": "2025-11-09T21:51:27", "operations": [ { "type": "vote_operation", "value": { "voter": "voter", "author": "test-author", "permlink": "test-permlink", "weight": 2200 } }

], "extensions": [], "signatures": ["1fe8647a82f1...98b418a"] } Whereas toLegacyApi() would output: { "ref_block_num": 1960, "ref_block_prefix": 3915120327, "expiration": "2025-11-09T21:51:27", "operations": [ ["vote", { "voter": "voter", "author": "test-author", "permlink": "test-permlink", "weight": 2200 }] ], "extensions": [], "signatures": ["1fe8647a82f1...98b418a"] } Notice the difference in how the operations array is structured.

In summary, the signing and broadcasting phase in WAX is very flexible. You can utilize secure signing (BeeKeeper or external wallets) and WAX will merge the signatures and handle final serialization. Once broadcast, your transaction is on its way to being included in a Hive block, completing the cycle of reading data, building a transaction, and writing data to the blockchain.

### Advanced Features: Binary Serialization and Transaction Inspection

As a developer, you might not need to delve into binary serialization often, but it’s useful to know that WAX provides access to it. Hive transactions, when sent over the network and used for signing, are actually serialized to a binary format (a sequence of bytes) according to the protocol’s rules. WAX can convert transactions to this binary form and back, which can be helpful for debugging or for interacting with lower- level systems.

Binary Transaction Format and HF26 Changes Prior to Hive’s Hardfork 26, operations in binary were serialized as a type ID (byte) followed by the operation data. After HF26, the serialization uses different type identifiers and accommodates the new JSON-based structure. WAX’s toBinaryForm() method will output a hex string representing the binary form of the transaction (by default including the signatures if any, unless you strip them).

Example – Converting to Binary:

const txHex = tx.toBinaryForm(); // hex string of the serialized tx (including signature fields if present) console.log("Transaction binary (hex):", txHex); You might see output like: 8059b32ca6018b9fb568010003677467036774670b68656c6c6f2d776f726c6498080000 (This corresponds to a particular transaction’s binary. It’s not human-readable, obviously.) If you want to see how that hex is composed, WAX provides tx.binaryViewMetadata which breaks down each field with offsets and lengths: const meta = tx.binaryViewMetadata; console.log(JSON.stringify(meta, null, 2)); This will output a detailed object describing each part. For example, it may list: - ref_block_num at offset 0 (2 bytes) - ref_block_prefix at offset 2 (4 bytes) - expiration at offset 6 (4 bytes, and it might even decode it to a timestamp) - operations (list length and then each operation’s details with offsets for each field) - extensions length - signatures length (0 if not signed yet) This is a debugging aid. The WAX documentation even includes a screenshot of a Binary View UI that was built using this metadata, allowing developers to visually inspect transaction bytes.

As for HF26 vs legacy: If you need the binary digest of a transaction for signing in the old way (pre-HF26) vs the new way, note that Hive changed the way the digest is computed in HF26 (the serialization of operations changed). WAX likely handles this internally based on whether you are using toLegacyApi or not. If you have to sign for older compatibility, ensure you construct the transaction in legacy format before hashing.

Converting from Binary (Parsing) WAX can also read a binary transaction. If you have a raw hex string (perhaps from a block log or another source), you can turn it into a WAX transaction object: const rawHex = "8059b32ca6018b9fb568010003677467..."; // some transaction hex const txParsed = chain.convertTransactionFromBinaryForm(rawHex); console.log("Parsed transaction:", txParsed); txParsed here would be a transaction object (probably an offline one) with all fields populated as per the binary. This is quite powerful if you are dealing with transaction data from a source that isn’t JSON. It means WAX could be used to build a blockchain explorer or analysis tool that reads transactions.

Putting It All Together: Transaction Lifecycle in WAX To recap the typical lifecycle with WAX: 1. Initialize the chain interface (connect to a node). 2. Fetch any necessary data (optional; e.g., account info for decisions or dynamic global props for conversions). 3. Create a transaction via createTransaction() – auto-fills ref block and expiration. 4. Add operations via pushOperation() – use simple ops or WAX’s operation classes. 5. (Optional) Verify the transaction with performOnChainVerification() – catches errors. 6. Sign the transaction using one or more signers (BeeKeeper or external). 7. Broadcast the transaction with chain.broadcast() to send it to the network. 8. Inspect results – you get a transaction ID which you can track on Hive (the transaction’s effects will also be visible, e.g., balances changing, posts appearing, etc., once included in a block).

Through each step, WAX provides helpful abstractions and safety checks.

### Hive Application Operations (Custom JSON Helpers)

Beyond the basic blockchain ops, Hive has a concept of custom JSON operations that allow implementing higher-level features in a decentralized way. Many Hive apps (social features, communities, games) rely on custom JSONs with specific formats that Hive’s consensus or middleware (like Hivemind social engine) recognize. Writing these by hand can be error-prone. WAX includes specialized helper classes for common “Hive application” operations, which essentially wrap custom JSON ops.

These include: - ResourceCreditsOperation – handles delegation of Resource Credits between accounts. - FollowOperation – handles follow/mute of blogs and reblogging content. - CommunityOperation – handles various community actions (joining/leaving, banning, flagging content, updating community settings).

These classes abstract the JSON structure and required auths, making it as easy as calling methods.

Example: Delegating Resource Credits Hive allows accounts to delegate a portion of their Resource Credits to another account (for example, a power user might delegate RC to a new user to help them transact more). This is done via a custom JSON on-chain (recognized by the RC plugin).

With WAX: import { ResourceCreditsOperation } from '@hiveio/wax'; const rcOp = new ResourceCreditsOperation(); rcOp.delegate("myaccount", 1000, "friend123") // delegate 1000 RC to friend123 .authorize("myaccount"); // specify which account (posting key) will sign this op tx.pushOperation(rcOp);

await signer1.signTransaction(tx); await chain.broadcast(tx); In the above: - rcOp.delegate(from, amount, to) builds a custom JSON to delegate amount RC from from to to . - You could also call rcOp.removeDelegation(from, target) to revoke a prior delegation. - The .authorize(account) call is crucial: it indicates that account is the one authorizing the custom JSON (meaning it will go into required_posting_auths for that custom_json op). You must then sign the transaction with that account’s posting key (hence we use posting auth for these social actions).

You can chain multiple calls before authorize if you want to include multiple RC operations in one custom JSON, but typically RC delegations are one at a time.

After pushing and signing, this transaction will appear on-chain as a custom_json operation with an id likely like "rc" or similar, containing something like ["delegateRC", {"from":"myaccount","to":"friend123","max\_rc":1000}] . WAX took care of that format for you.

Example: Following, Muting, Reblogging The social aspect of Hive allows users to follow or mute others’ content, and reblog (share) posts to their feed. These are implemented via custom JSON with id "follow" .

Using FollowOperation class: import { FollowOperation } from '@hiveio/wax'; const followOp = new FollowOperation(); followOp.followBlog("alice", "bob") // alice follows bob's blog .muteBlog("alice", "spammyuser") // alice mutes another user .reblog("alice", "charlie", "post-permlink") // alice reblogs charlie's post .authorize("alice"); tx.pushOperation(followOp); await signerAlice.signTransaction(tx); await chain.broadcast(tx); Here we combined three actions (follow, mute, reblog) for Alice in one transaction. Under the hood, this likely creates multiple custom_json ops or a single op with a combined array (depending on Hive’s expectations – historically each follow or reblog is a separate custom_json). The WAX docs example shows that pushing FollowOperation with multiple calls results in multiple operations in the transaction (one for follow, one for mute, one for reblog) which is fine.21

Note: The authorize("alice") means the custom_json operations will list Alice’s name in required_posting_auths . Therefore, the signing key needed is Alice’s posting key (which we denote as signerAlice here). Each of those sub-operations uses posting authority.

This greatly simplifies writing, say, a social media app where you want a user to follow or reblog content: you don’t have to manually format the JSON like {"follower":"alice","following":"bob",...} etc., WAX does it.

Example: Community Operations Hive Communities (like subreddit-like groups on Hive) also use custom JSONs (id "community" ). The CommunityOperation class helps with actions like joining a community, leaving, flagging a post within a community, or updating community settings (if you are an admin).

For a regular user: subscribe and flag content in a community: import { CommunityOperation } from '@hiveio/wax'; const commOp = new CommunityOperation(); commOp.subscribe("hive-123456") // join community with alias "hive-123456" .flagPost("hive-123456", "baduser", "spam-post-permlink", "Spam content") .authorize("myaccount"); tx.pushOperation(commOp); await signerMyAccount.signTransaction(tx); await chain.broadcast(tx); This would produce two custom_json ops under the hood: one for subscribing to the community, and one for flagging a post (with some notes). The authorize("myaccount") again places myaccount in posting auths and we sign with posting key.

For a community moderator/admin: updating community properties: commOp.updateProps("hive-123456", { title: "New Community Title", about: "Short description", description: "Longer description of the community", flag_text: "Rules for flagging posts...", is_nsfw: false, lang: ESupportedLanguages.ENGLISH }) .authorize("myaccount"); tx.pushOperation(commOp); // sign and broadcast

In the output you would see a custom_json with id "community" and json payload like ["updateProps", { "community":"hive-123456", "props":{...} }] . WAX took your nice object with various fields and turned it into the correct JSON structure (including converting the language enum to the two-letter code, etc.).

Always remember to call .authorize(account) on these operation builders – without it, WAX doesn’t know which account is authorizing the custom_json (since these ops don’t use active authority, they use posting). If you forget, you might end up with an invalid operation or missing required_posting_auth and your transaction will be rejected.

In one transaction, you should typically use one instance of each operation class. For example, you could do: tx.pushOperation( new FollowOperation().followBlog("a","b").authorize("a") ); tx.pushOperation( new CommunityOperation().subscribe("hive-1").authorize("a") ); This would create two ops (one custom_json of type follow, one of type community) in one transaction, both authorized by "a" and both signed by "a"'s posting key.

Summary of Hive App Helpers WAX’s Hive application operation helpers drastically reduce the effort to integrate social features: - ResourceCreditsOperation – delegate or revoke delegation of RC (helpful for onboarding or resource sharing). - FollowOperation – manage following/muting of blogs and reblogging content (for building social feeds, etc.). - CommunityOperation – manage community membership and administration (join/ leave communities, moderate content, update settings).

They ensure you craft the correct JSON and include the proper required auths. Without WAX, a developer would have to remember the exact JSON format and the required_posting_auths vs required_auths arrays to populate – an easy place to make a mistake.

Each of these classes likely covers most functions available in their respective custom JSON protocols. If Hive introduces new social operations, WAX can be updated to include them as well.

### Use Cases and Applications of WAX

With a solid understanding of WAX’s features, let’s consider how and when to use WAX in real-world development:

- Web and Mobile dApps: If you’re building a Hive-powered application (for example, a front-end for social blogging, a game using Hive transactions, or a wallet interface), WAX in JavaScript can serve as

your all-in-one library. You can fetch data (e.g., get content, profiles), and you can publish content or interact (votes, comments, transfers) using WAX’s transaction building. The built-in safety checks (like preventing key leaks) are especially valuable in UIs where users might paste keys or content – WAX acts as an additional safeguard before broadcasting. WAX is also browser-friendly (with proper bundling) and can work with frameworks like React or Vue.

- Backend Services and Bots: In a Node.js environment (or Python, if you choose that version of WAX), you can use WAX to build automation. For example, a curation bot that scans for certain posts and upvotes them can use chain.database calls to get posts and then use WAX to create vote transactions. The Workerbee library (built on WAX) even provides higher-level patterns for recurring tasks. WAX’s robust transaction tools (like ability to easily do multisig or handle many operations) make it ideal for complex backend workflows (like processing a batch of payments).

- Cross-Platform Development: Because WAX is multi-language, a project can have components in different languages all using WAX. For instance, you might write a high-performance service in C++ for heavy blockchain parsing and also a quick Node.js script for an express API server – both can use WAX and share similar logic for transaction handling. This cross-language consistency lowers the learning curve when switching contexts.

- Offline Transaction Signing: If you are dealing with high-security scenarios (cold storage or hardware wallets), WAX’s Base interface allows you to construct a transaction JSON on an online machine, then move it offline to sign. The offline environment (using WAX Base) can deserialize the JSON ( createTransactionFromJson ), compute the digest ( sigDigest ), and you can sign it with a private key on that machine (perhaps using BeeKeeper compiled to WASM or a hardware wallet interface). Then you could bring the signature back and attach it with addSignature . This way, the sensitive key never touches an online machine. WAX makes this feasible by cleanly separating transaction creation from signing.

- Integration with Existing Wallets: Suppose you prefer using Hive Keychain in your app (so users use the browser extension to sign). WAX can still be extremely useful to build the transaction. You can build the tx with WAX, use tx.toLegacyApi() to get the old-style operation array, then call window.hive_keychain.requestBroadcast(...) with that. Once Keychain signs and broadcasts, you could even use WAX to parse the returned transaction or monitor it. Essentially, WAX doesn’t force you to use its signing; you can mix and match – use WAX for constructing transactions reliably and another tool for signing if needed.

- Custom JSON-heavy Applications: Many second-layer Hive apps (like Splinterlands game, or DCity, or other Hive games, or community tools) revolve around custom JSON operations. WAX’s helper classes (and extendibility if you need to define your own custom JSON format) simplify this. If you’re developing a new game where players send moves via custom JSON, you could extend WAX to support your game’s JSON structure, giving yourself and others a typesafe way to create those ops.

- Educational and Inspection Tools: Because WAX exposes binary conversion and introspection, it’s also a great tool for learning and debugging. You could build a transaction explorer that takes a tx from a block and decodes it field by field using WAX’s metadata. This is especially useful to understand how certain operations look under the hood or to verify that your signing process is correct (comparing sig digests, etc.).

In short, WAX is suitable whenever you want a full-featured, up-to-date Hive library that handles both the API side (reads) and transaction side (writes). It’s particularly beneficial for long-running projects that need to remain compatible with Hive’s evolution, since WAX’s design (using core definitions) means you’re less likely to be broken by a future hardfork.

However, it’s also important to consider where WAX might not be the best fit: - Lightweight Scripts: If you’re writing a very simple one-off script (say, a Node.js script to just transfer some tokens) and you want minimal dependencies, WAX might feel heavier than necessary. A lightweight library like hive-tx (which only does transactions and nothing else) or direct RPC calls could suffice. WAX brings a lot of functionality, which comes with a larger bundle size and learning overhead. - Very Performance-Critical Loops: WAX’s abstractions (like performing extra verification, or using classes) have a small cost. Usually negligible for normal use, but if you are constructing thousands of transactions in a tight loop, you might profile to see if those checks can be turned off or if a more bare-bones approach is needed. That said, WAX is built with performance in mind (using compiled protocol buffers). - Environments not supported: WAX aims to run in Node and modern browsers. If you have to run in an extremely constrained environment (say an older browser or a non-JS environment without using the C++ version), you might encounter issues. For example, embedding WAX’s C++ library in certain mobile apps might require some work with compilation.

Overall, for most Hive developers, WAX offers an unprecedented combination of power, safety, and consistency. It effectively supersedes older libraries like hive-js and dhive by addressing their limitations. Let’s directly compare to see why you might choose WAX.

### WAX vs Older Hive Libraries (Comparison)

Several Hive libraries have been used historically: hive-js (an older JavaScript library), dhive (a community TypeScript library), and others like hive-tx (minimal JS lib), beem (Python), etc. WAX is a more recent entrant. Here’s a comparison focusing on WAX and a typical older JS library (dhive): Aspect WAX (@hiveio/wax) dHive / hive-js (Older) Language Multi-language: available in TypeScript/JS, Python, C++ JavaScript/TypeScript only (each other language Support (same API concepts in each) had separate lib) Uses official Hive Protobuf definitions – auto-includes all Manually maintained op definitions. New ops Protocol operations and fields, so it’s (from hardforks) require library updates. Lag Compatibility [always up-to-date with hardfork](https://developers.hive.io/quickstart/#:~:text=Wax%20is%20a%20multi,with%20the%20core%20blockchain%20protocol) changes [1](https://developers.hive.io/quickstart/#:~:text=Wax%20is%20a%20multi,with%20the%20core%20blockchain%20protocol) . Less maintenance possible if maintainers are slow to update, needed; low risk of missing new causing unsupported ops or fields.

ops.

Full RPC API coverage with IntelliSense (via pre-defined API categories). Also extendable for Provides core API methods (database, broadcast, API Coverage custom calls. WAX includes etc.), but no special helpers for custom JSON high-level helpers for social operations – developer must form JSON manually.

features (follow, etc.) out of the box.

Aspect WAX (@hiveio/wax) dHive / hive-js (Older) Unified builder Often offered convenience methods per ( createTransaction() , operation, e.g.

pushOperation ) for any op. client.broadcast.transfer({...}, key) No need to manually gather for a single op. For multiple ops, dev had to Transaction ref_block data (WAX does it). manually construct the operations array and call a Building Complex operations supported generic broadcast. Getting ref_block and via classes (encapsulating expiration was sometimes manual in older binary serialization details). libraries (though dhive did auto-fetch if using its Supports both new and legacy Client in certain ways). Fewer abstractions for JSON formats easily. multi-op transactions.

Built-in on-chain verification (catches private key leaks in Safety content, checks account No automatic safety checks. If you broadcast a transaction with a bad memo or non-existent Features existence, authority satisfaction) before broadcast.

account, you’d only find out from a node error. No Reduces risk of errors and prevention of leaking keys accidentally.

accidents in production.

Designed to work with external Typically expects developer to provide a private secure signers (BeeKeeper, key (WIF) directly to sign. E.g., dhive allows hardware wallets). Does not PrivateKey.from(...) and passing that to Key expose raw key handling in broadcast. Simpler, but it means the app handles Management high-level API – you supply a raw keys often. Integration with external signers signer or use BeeKeeper’s (Keychain, etc.) not inherently managed by the integration. This encourages library (though possible by manually using better security practices (keys client.broadcast.send() with a provided can be isolated). signature).

Supports multi-signature easily: While older libs can do multi-sig (e.g., by Multi-Sig and can add multiple signatures to providing multiple keys to broadcast), they don’t Authority a tx, and provides authority provide debugging info or a structured way to trace to debug complex incrementally sign. The developer had to ensure authority requirements. all needed keys were provided.

Native asset classes and conversion functions (HIVE/ HBD/VESTS with NAI format).

Typically used string asset format or simple Asset Developer doesn’t worry about number conversions. Developer might have to Handling precision or string formats.

format "X.XXX HIVE" strings manually. Some Convenient helpers for vesting conversion utilities (like for vest to HP) were not conversions and price present or had to be coded manually.

calculations.

Aspect WAX (@hiveio/wax) dHive / hive-js (Older) Part of a broader Hive developer ecosystem: works in dhive and hive-js were community-maintained tandem with BeeKeeper (key (hive-js was a fork of steem-js by Hive developers Extensibility management), and Workerbee but not as actively developed in recent times).

& Ecosystem (automation on top of WAX). They have served well, but new feature Supported by core Hive development is limited. Fewer complementary developers (e.g., BlockTrades tools (though hive-keychain works alongside any team), suggesting ongoing lib, it’s external).

maintenance and integration.

WAX is efficient (utilizes compiled schema), but the dhive is lightweight and proven in production for library size is larger due to years. It might have a smaller bundle if you only Performance including all ops and protobuf need certain parts. In edge cases, direct JSON logic. For most applications, usage might be slightly faster since it skips performance is more than verification overhead.

sufficient.

Moderately high-level, but with consistency comes some Simpler for quick tasks: one-liner operations (like learning: e.g., understanding client.broadcast.vote(...) ) were Learning ITransaction builder pattern, straightforward. However, doing more complex Curve and using external signers. things required diving into docs anyway. The Good documentation and conceptual model (especially after HF26 changes) examples are available (as we isn’t simpler than WAX, just different.

have seen).

In summary, WAX tends to be safer and more comprehensive, at the cost of a slightly larger footprint and a shift to a builder paradigm. Older libraries might be simpler for trivial tasks and have a smaller dependency size, but they lack many of WAX’s modern features and guarantees. Given that Hive development is ongoing, using WAX means your app is less likely to break when new features arrive (since WAX will handle them seamlessly).

Where WAX May Not Be As Good: As an honest assessment, a few scenarios where an older or different approach might be chosen: - If you are constrained by environment (e.g., you need a pure JS solution with no build process, you might use the older hive-js which could be included via </x-turndown> tag easily; WAX likely requires a bundler). - If your app is extremely size-sensitive (like a very small browser widget) and only needs one specific operation, a custom minimal code might be smaller than including WAX. - If you already have a stable codebase on dhive/hive-js and it works, migrating to WAX would require some refactoring to the new patterns (which might not be immediately justifiable unless you need WAX’s new capabilities). - For quick scripting or experimentation, some devs might prefer the quick client.database.getX() and client.broadcast.Y() style of dhive because it’s a bit less abstract than managing a transaction object and signers. However, this is mostly about familiarity.

For most new projects, the benefits of WAX likely outweigh these considerations. The Hive developer community is moving in the direction of WAX + BeeKeeper as the standard stack (with tools like Clive wallet being built on them).

### Conclusion

The Hive WAX library represents the ultimate toolkit for Hive blockchain development in 2025 and beyond. It consolidates the scattered capabilities of previous libraries into one cohesive package: - It enables reading blockchain data through a robust API interface. - It simplifies building transactions with correctness and future-proofing (thanks to protocol-derived definitions). - It enhances security by integrating with secure key management and performing pre-broadcast checks that catch errors early. - It provides high-level abstractions for complex operations (social features, witness actions), reducing the cognitive load on developers. - It ensures your app stays compatible with Hive’s evolution, as WAX is maintained alongside core Hive changes.

By using WAX, developers can focus on their application’s logic and user experience, rather than worrying about low-level encoding details or edge-case pitfalls. Whether you’re creating a new decentralized app, a wallet service, or automation scripts, WAX offers a reliable and comprehensive foundation.

As we have compiled everything in this guide – from initial setup, key management, transaction construction, to advanced usage and comparisons – you should now have a one-stop reference for working [with WAX. With this knowledge, you can confidently leverage Hive’s powerful features and build the next](https://developers.hive.io/quickstart/#:~:text=Wax%20is%20a%20multi,with%20the%20core%20blockchain%20protocol) generation of Hive applications with ease and security. Happy coding on Hive with WAX! [1](https://developers.hive.io/quickstart/#:~:text=Wax%20is%20a%20multi,with%20the%20core%20blockchain%20protocol) [3](https://hive.pages.syncad.com/wax-doc/default/interfaces/asset-manipulations/construct-nai-asset/#:~:text=,and%20type%20must%20be%20specified) [1](https://developers.hive.io/quickstart/#:~:text=Wax%20is%20a%20multi,with%20the%20core%20blockchain%20protocol) [Getting started](https://developers.hive.io/quickstart/) [https://developers.hive.io/quickstart/](https://developers.hive.io/quickstart/) [2](https://hive.pages.syncad.com/wax-doc/default/interfaces/transaction-and-operation/#:~:text=The%20hive%20software%20requires%20every,This%20hash%20serves%20two%20purposes) [Hive Protocol: Transaction and Operations | Wax](https://hive.pages.syncad.com/wax-doc/default/interfaces/transaction-and-operation/) [📚](https://hive.pages.syncad.com/wax-doc/default/interfaces/transaction-and-operation/) [https://hive.pages.syncad.com/wax-doc/default/interfaces/transaction-and-operation/](https://hive.pages.syncad.com/wax-doc/default/interfaces/transaction-and-operation/) [3](https://hive.pages.syncad.com/wax-doc/default/interfaces/asset-manipulations/construct-nai-asset/#:~:text=,and%20type%20must%20be%20specified) [NaiAsset objects | Wax](https://hive.pages.syncad.com/wax-doc/default/interfaces/asset-manipulations/construct-nai-asset/) [📚](https://hive.pages.syncad.com/wax-doc/default/interfaces/asset-manipulations/construct-nai-asset/) [https://hive.pages.syncad.com/wax-doc/default/interfaces/asset-manipulations/construct-nai-asset/](https://hive.pages.syncad.com/wax-doc/default/interfaces/asset-manipulations/construct-nai-asset/) [4](https://hive.pages.syncad.com/wax-doc/default/interfaces/asset-manipulations/generating-assets/#:~:text=%2F%2F%20Example%20of%20exceeding%20the,precision%20limit%20for%20fractional%20parts) [Asset creation function details | Wax](https://hive.pages.syncad.com/wax-doc/default/interfaces/asset-manipulations/generating-assets/) [📚](https://hive.pages.syncad.com/wax-doc/default/interfaces/asset-manipulations/generating-assets/) [https://hive.pages.syncad.com/wax-doc/default/interfaces/asset-manipulations/generating-assets/](https://hive.pages.syncad.com/wax-doc/default/interfaces/asset-manipulations/generating-assets/)
